#include<iostream>
#include<string>
#include<iomanip>
#include<fstream>
using namespace std;
#pragma warning(disable:4996)

#define OK 1
#define ERROR 0
#define OVERFLOW -2
typedef int Status;
typedef int ElemType;

struct Book {
	string id;
	string name;
	double price;
};
typedef struct LNode {
	Book data;
	struct LNode *next;
} LNode, *LinkList;

string head_1, head_2, head_3;
int length;

Status InitList_L(LinkList &L) {
	L = new LNode;
	L->next = NULL;
	return OK;
}

Status GetElem_L(LinkList L, int i, Book &e) {
	int j;
	LinkList p;
	p = L->next;
	j = 1;
	while (j < i && p) {
		p = p->next;
		++j;
	}
	if (!p || j > i) return ERROR;
	e = p->data;
	return OK;
}

LNode *LocateElem_L(LinkList L, int e) {
	LinkList p;
	p = L->next;
	while (p && p->data.price != e) p = p->next;
	return p;
}

Status ListInsert_L(LinkList &L, int i, Book &e) {
	int j;
	LinkList p, s;
	p = L;
	j = 0;
	while (p && j < i - 1) {
		p = p->next;
		++j;
	}
	if (!p || j > i - 1) return ERROR;
	s = new LNode;
	s->data = e;
	s->next = p->next;
	p->next = s;
	++length;
	return OK;
}

Status ListDelete_L(LinkList &L, int i) {
	LinkList p, q;
	int j;
	p = L;
	j = 0;
	while ((p->next) && (j < i - 1)){
		p = p->next;
		++j;
	}
	if (!(p->next) || (j > i - 1)) return ERROR;
	q = p->next;
	p->next = q->next;
	delete q;
	--length;
	return OK;
} //ListDelete_L

void CreateList_H(LinkList &L, int n) {
	LinkList p;
	L = new LNode;
	L->next = NULL;
	length = 0;
	fstream file;
	file.open("book2.txt");
	if (!file) {
		cout << "未找到相关文件，无法打开！" << endl;
		exit(ERROR);
	}
	file >> head_1 >> head_2 >> head_3;
	while (!file.eof()) {
		p = new LNode;
		file >> p->data.id >> p->data.name >> p->data.price;
		p->next = L->next;
		L->next = p;
		length++;
	}
	file.close();
}

void CreateList_R(LinkList &L, int n) {
	LinkList p, r;
	L = new LNode;
	L->next = NULL;
	r = L;
	length = 0;
	fstream file;
	file.open("book2.txt");
	if (!file) {
		cout << "未找到相关文件，无法打开！" << endl;
		exit(ERROR);
	}
	file >> head_1 >> head_2 >> head_3;
	while (!file.eof()) {
		p = new LNode;
		file >> p->data.id >> p->data.name >> p->data.price;
		p->next = NULL;
		r->next = p;	
		r = p;
		length++;
	}
	file.close();
}

void OutputList(LinkList& L) {
	LinkList p = L->next;
	while (p) {
		cout << left << setw(15) << p->data.id << "\t" << left << setw(
			50) << p->data.name << "\t" << left << setw(5)
			<< p->data.price << endl;
		p = p->next;
	}
}

void Input_Keyboard(LinkList& L) {
	LinkList p, r;
	L = new LNode;
	L->next = NULL;
	r = L;
	length = 0;
	int n;
	cout << "请输入书籍数量: ";
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		p = new LNode;
		cin >> p->data.id >> p->data.name >> p->data.price;
		p->next = NULL;
		r->next = p;	
		r = p;
		length++;
	}
	cout << "插入" << length << "本书成功！" << endl;
}

void Updata_books(LinkList& L) {
	LinkList p = L;
	fstream file;
	file.open("book_updata.txt");
	if (!file) {
		cout << "未找到相关文件，无法打开！" << endl;
		exit(ERROR);
	}

	//数据写入文件
	while (p->next != NULL) {
		p = p->next;
		file << p->data.id << " " << p->data.name << " " << p->data.price << endl;
	}
	file.close();
}

void PriceUp(LinkList& L) {
	LinkList pfirst;
	LinkList psecond;
	LinkList pend = NULL;
	pfirst = L;
	psecond = L;
	Book temp;
	while (pfirst != pend) {
		while (pfirst->next != pend) {
			if (pfirst->data.price > pfirst->next->data.price) {
				temp = pfirst->data;
				pfirst->data = pfirst->next->data;
				pfirst->next->data = temp;
			}
			pfirst = pfirst->next;
		}
		pend = pfirst;
		pfirst = L;
	}
	OutputList(L);
}

int FixPrice(LinkList& L) {
	LinkList p = L;
	string id;
	double price;
	int flag = 0;
	printf("id:");
	getchar();
	scanf("%s", &id);
	printf("price:");
	getchar();
	scanf("%lf", &price);
	while (p->next != NULL) {
		if (id.compare(p->next->data.id) == 0) {
			p = p->next;
			p->data.price = price;
			flag = 1;
			cout << "修改成功" << endl;
			return 1;
		}
		p = p->next;
	}
	if (flag == 0) {
		cout << "修改失败" << endl;
	}
	return 1;
}

Status DeleteRepeat(LinkList& L) {
	LinkList p;
	LinkList mark;
	LinkList q;
	for (mark = L->next; mark != NULL; mark = mark->next)
	{
		q = mark;
		p = mark->next;
		while (p)
		{
			if (mark->data.id.compare(p->data.id) == 0)
			{
				q->next = p->next;
				free(p);
				p = q->next;
			}
			else
			{
				q = p;
				p = p->next;
			}
		}
	}
	OutputList(L);
	cout << "去重成功" << endl;
	return OK;
}

int main() {
	int a, choose;
	double price;
	Book e;
	LinkList L;
	if (InitList_L(L)) cout << "成功建立链表!\n\n";
	//cout << "1. 建立\n";
	cout << "1. 输入\n";
	cout << "2. 取值\n";
	cout << "3. 查找\n";
	cout << "4. 插入\n";
	cout << "5. 删除\n";
	cout << "6. 输出\n";
	cout << "7. 导出文件\n";
	cout << "8. 价格逆序\n";
	cout << "9. 图书去重\n";
	cout << "0. 退出\n\n";

	choose = -1;
	while (choose != 0) {
		cout << "请选择:";
		cin >> choose;
		switch (choose) {
		case 1: //键盘输入书籍内容
			Input_Keyboard(L);
			break;
		case 2: //单链表的按序号取值
			cout << "请输入一个位置用来取值:";
			cin >> a;
			if (GetElem_L(L, a, e)) {
				cout << "查找成功\n";
				cout << "第" << a << "本图书的信息是：\n";
				cout << left << setw(15) << e.id << "\t" << left << setw(50)
					<< e.name << "\t" << left << setw(5) << e.price << endl
					<< endl;
			}
			else
				cout << "查找失败\n\n";
			break;
		case 3: //单链表的按值查找
			cout << "请输入所要查找价格:";
			cin >> price;
			if (LocateElem_L(L, price) != NULL) {
				cout << "查找成功\n";
				cout << "该价格对应的书名为：" << LocateElem_L(L, price)->data.name
					<< endl << endl;
			}
			else
				cout << "查找失败! 定价" << price << " 没有找到\n\n";
			break;
		case 4: //单链表的插入
			cout << "请输入插入的位置和书的信息，包括：编号 书名 价格（用空格隔开）:";
			cin >> a;
			cin >> e.id >> e.name >> e.price;
			if (ListInsert_L(L, a, e))
				cout << "插入成功.\n\n";
			else
				cout << "插入失败!\n\n";
			break;
		case 5: //单链表的删除
			cout << "请输入所要删除的书籍的位置:";
			cin >> a;
			if (ListDelete_L(L, a))
				cout << "删除成功!\n\n";
			else
				cout << "删除失败!\n\n";
			break;
		case 6: //单链表的输出
			OutputList(L);
			cout << "输出成功" << endl;
			break;
		case 7: //导出为文件
			Updata_books(L);
			cout << "数据更新成功！\n" << endl;
			break;
		case 8: //价格逆序
			PriceUp(L);
			cout << "排序完成" << endl << endl;
			break;
		case 9: //图书去重
			DeleteRepeat(L);
			break;
		}
	}
	return 0;
}
